classdef Lin_Mvng_Stpt_Cntr_SS < handle
    %UNTITLED Summary of this class goes here
    %   Detailed explanation goes here
    
    properties (SetAccess = private)
        
        sys_mats %System Matrices
        sim_response %Latest system response for this object
        ctrl_type %The type of control system this object represents 
                  %(SS Integral Controller, or SS PID Controller)
    end
    
    
    methods
        function obj = Lin_Mvng_Stpt_Cntr_SS(Lnrzed_EOMs,VDefs,type)
            %Lin_Mvng_Stpt_Cntr_SS Construct an instance of this class
            %   Detailed explanation goes here
            
            switch type
                
                case 'SS Integral Controller'
                    
                    %Set this object's controller type
                    obj.ctrl_type = type;
                    
                    %Augmented A Matrix
                    obj.sys_mats.Aa = [zeros(5,1),[-1 0 0 0; Lnrzed_EOMs.A1]]; 
                    
                    %Augmented B Matrix
                    obj.sys_mats.Ba = [0;Lnrzed_EOMs.B1];
                    
                    %S matrix, the setpoint matrix
                    obj.sys_mats.S = sym([1;0;0;0;0]);
                    
                    %Our desired control output is the x state (want it to match as 
                    %closely as possible to x_s for all times). C and D select the x state
                    %from the augmented state vector
                    obj.sys_mats.C = sym([0 1 0 0 0]); 
                    obj.sys_mats.D = 0;  
                    
                    %x setpoint selector matrix (plotting in Simulink purposes)
                    obj.sys_mats.x_s_select = 1;
                case 'SS PID Controller'    
                    
                    %Set this object's controller type
                    obj.ctrl_type = type;
                    
                    %State vector augmented with integral of the error in x AND with x and x_dot replaced with error states
                    stateVec_a_PID = [VDefs.e_ix, VDefs.e_x, VDefs.e_x_dot, VDefs.beta, VDefs.beta_dot].';
                    stateVec_a_PID_dot = [VDefs.e_x, VDefs.e_x_dot, VDefs.e_x_ddot, VDefs.beta_dot, VDefs.beta_ddot].';
                    x_1a_dot_eqn = stateVec_a_PID_dot == [e_x e_x_dot (x_ddot_s - x_ddot) beta_dot rhs(Lnrzed_EOMs.LIN_EOMS1(4))].';
                    x_1a_dot_eqn = stateVec_a_PID_dot == subs(rhs(x_1a_dot_eqn), x_ddot , rhs(Lnrzed_EOMs.LIN_EOMS1(2)));
                    x_1a_dot_eqn = subs(x_1a_dot_eqn, x, x_s - e_x);

                    obj.sys_mats.Aa = equationsToMatrix(rhs(x_1a_dot_eqn), stateVec_a_PID);
                    obj.sys_mats.Ba = equationsToMatrix(rhs(x_1a_dot_eqn), T_beta);

                    setpointVec1 = [x_s x_dot_s x_ddot_s].';
                    S1a = equationsToMatrix(rhs(x_1a_dot_eqn), setpointVec1)
                    
                    
                otherwise
                    error('Not a valid moving setpoint controller type')
                    
            end 
        end
        
        
        function [] = Run_Sim(obj,setpoint_symfun, tspan, xa_0, K)
            %METHOD1 Summary of this method goes here
            %   Detailed explanation goes here
         
            
            %Set the Simulink Parameters (Matrices, times, gains, etc.)
        
                %Timespan
                tspan = Simulink.Parameter(tspan);
                assignin('base', 'tspan', tspan)

                %ICs
                xa_0 = Simulink.Parameter(xa_0);
                assignin('base', 'xa_0', xa_0);

                %Symbolic matrices derived or assigned in the constructor
                Aa = Simulink.Parameter(double(obj.sys_mats.Aa));
                assignin('base', 'Aa', Aa); %Create the simulink paramter in the base workspace 
                Ba = Simulink.Parameter(double(obj.sys_mats.Ba));
                assignin('base', 'Ba', Ba); %Create the simulink paramter in the base workspace 
                S = Simulink.Parameter(double(obj.sys_mats.S));
                assignin('base', 'S', S); %Create the simulink paramter in the base workspace 
                C = Simulink.Parameter(double(obj.sys_mats.C));
                assignin('base', 'C', C); %Create the simulink paramter in the base workspace 
                D = Simulink.Parameter(double(obj.sys_mats.D));
                assignin('base', 'D', D); %Create the simulink paramter in the base workspace 
                x_s_select = Simulink.Parameter(obj.sys_mats.x_s_select);
                assignin('base', 'x_s_select', x_s_select); %Create the simulink paramter in the base workspace         

                %Gain matrix K
                K = Simulink.Parameter(K);
                assignin('base', 'K', K); %Create the simulink paramter in the base workspace   
            
            %Replace the definition of the "Input_Function" MATLAB function block with the
            %setpoint_symfun input
                matlabFunctionBlock('Linear_Moving_Setpoint_SS/Input_Function', setpoint_symfun)
            
            %Run the simulation    
                obj.sim_response = sim('Linear_Moving_Setpoint_SS');
                
            
        end
        
        function [figure_obj] = plot_results(obj)
            %plot_results Summary of this method goes here
            %   Detailed explanation goes here 
            
            switch obj.ctrl_type
                
                
                
                
                case 'SS Integral Controller'
                    
                    figure_obj = figure;
                    ax1 = subplot(3,1,1);
                    plot(obj.sim_response.tout,obj.sim_response.y,...
                        obj.sim_response.tout,obj.sim_response.x_s_vec,'--' )
                    xlabel('time [s]')
                    ylabel('x [mm]')
                    title('Integral control with full state feedback pole placement')


                    ax2 = subplot(3,1,2);
                    plot(obj.sim_response.tout,rad2deg(obj.sim_response.xa(:,4)))
                    xlabel('time [s]')
                    ylabel('\beta [deg]')


                    ax3 = subplot(3,1,3);
                    plot(obj.sim_response.tout,obj.sim_response.T)
                    xlabel('time [s]')
                    ylabel('Torque [mNm]')
                    linkaxes([ax1,ax2, ax3],'x');
                    set(gcf,'position',[0,0,800,900]);   
                    

                    
                    
                    
                case 'SS PID Controller' 
                    
                    
                    
                    
            end 
            
        end 
%         
%         function [] = create_animation(obj)
%             %METHOD3 Summary of this method goes here
%             %   Detailed explanation goes here
%         end 
        
    end
end

