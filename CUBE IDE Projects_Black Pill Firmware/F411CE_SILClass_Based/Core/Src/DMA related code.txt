/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{

	/* DMA controller clock enable */
	__HAL_RCC_DMA2_CLK_ENABLE();
	__HAL_RCC_DMA1_CLK_ENABLE();

	/* DMA interrupt init */
	/* DMA1_Stream0_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Stream0_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA1_Stream0_IRQn);
	/* DMA2_Stream0_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
	/* DMA2_Stream7_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA2_Stream7_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA2_Stream7_IRQn);

}






/*This function is  run at the end of each call to ProcessPositionData() in the main loop.
It's also run elswhere, particularly in the TouchscreenDriver::TIM_Callback function*/

/**
  * @brief  Enables ADC DMA request after last transfer (Single-ADC mode) and enables ADC peripheral  
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.
  * @param  pData The destination Buffer address.
  * @param  Length The length of data to be transferred from ADC peripheral to memory.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
{
  __IO uint32_t counter = 0U;
  ADC_Common_TypeDef *tmpADC_Common;
  
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
  assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge)); 
  
  /* Process locked */
  __HAL_LOCK(hadc);
  
  /* Enable the ADC peripheral */
  /* Check if ADC peripheral is disabled in order to enable it and wait during 
  Tstab time the ADC's stabilization */
  if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
  {  
    /* Enable the Peripheral */
    __HAL_ADC_ENABLE(hadc);
    
    /* Delay for ADC stabilization time */
    /* Compute number of CPU cycles to wait for */
    counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
    while(counter != 0U)
    {
      counter--;
    }
  }
  
  /* Check ADC DMA Mode                                                     */
  /* - disable the DMA Mode if it is already enabled                        */
  if((hadc->Instance->CR2 & ADC_CR2_DMA) == ADC_CR2_DMA)
  {
    CLEAR_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
  }
  
  /* Start conversion if ADC is effectively enabled */
  if(HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_ADON))
  {
    /* Set ADC state                                                          */
    /* - Clear state bitfield related to regular group conversion results     */
    /* - Set state bitfield related to regular group operation                */
    ADC_STATE_CLR_SET(hadc->State,
                      HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR,
                      HAL_ADC_STATE_REG_BUSY);
    
    /* If conversions on group regular are also triggering group injected,    */
    /* update ADC state.                                                      */
    if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
    {
      ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
    }
    
    /* State machine update: Check if an injected conversion is ongoing */
    if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
    {
      /* Reset ADC error code fields related to conversions on group regular */
      CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
    }
    else
    {
      /* Reset ADC all error code fields */
      ADC_CLEAR_ERRORCODE(hadc);
    }

    /* Process unlocked */
    /* Unlock before starting ADC conversions: in case of potential           */
    /* interruption, to let the process to ADC IRQ Handler.                   */
    __HAL_UNLOCK(hadc);   

    /* Pointer to the common control register to which is belonging hadc    */
    /* (Depending on STM32F4 product, there may be up to 3 ADCs and 1 common */
    /* control register)                                                    */
    tmpADC_Common = ADC_COMMON_REGISTER(hadc);

    /* Set the DMA transfer complete callback */
    hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;

    /* Set the DMA half transfer complete callback */
    hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
    
    /* Set the DMA error callback */
    hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;

    
    /* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC     */
    /* start (in case of SW start):                                           */
    
    /* Clear regular group conversion flag and overrun flag */
    /* (To ensure of no unknown state from potential previous ADC operations) */
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC | ADC_FLAG_OVR);

    /* Enable ADC overrun interrupt */
    __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
    
    /* Enable ADC DMA mode */
    hadc->Instance->CR2 |= ADC_CR2_DMA;
    
    /* Start the DMA channel */
    HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
    
    /* Check if Multimode enabled */
    if(HAL_IS_BIT_CLR(tmpADC_Common->CCR, ADC_CCR_MULTI))
    {
#if defined(ADC2) && defined(ADC3)
      if((hadc->Instance == ADC1) || ((hadc->Instance == ADC2) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_0)) \
                                  || ((hadc->Instance == ADC3) && ((ADC->CCR & ADC_CCR_MULTI_Msk) < ADC_CCR_MULTI_4)))
      {
#endif /* ADC2 || ADC3 */
        /* if no external trigger present enable software conversion of regular channels */
        if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
        {
          /* Enable the selected ADC software conversion for regular group */
          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
        }
#if defined(ADC2) && defined(ADC3)
      }
#endif /* ADC2 || ADC3 */
    }
    else
    {
      /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
      if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
      {
        /* Enable the selected ADC software conversion for regular group */
          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
      }
    }
  }
  else
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);

    /* Set ADC error code to ADC IP internal error */
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
  }
  
  /* Return function status */
  return HAL_OK;
}



/*It is run on this line of code, very bottom of the position data function*/


	//End with starting DMA for now:
	HAL_ADC_Start_DMA(hadc, (uint32_t*)xposADC, ADC_BUF_LEN);

//I'm confused why only xposADC is being used and not yposADC



//I believe this code is run at some timer-based frequency. It's a callback in main that uses a wrapper function 
//defined in the touchscreen driver class (for touchscreen, 
//the settling time of the analog measurements. Clearly the HAL_ADC_Start_DMA function is run here as well
//but I'm confused why this time it's the yposADC buffer instead of the xposADC buffer. 


void TouchscreenDriver::TIM_Callback(void)
{
	//Logic handler for touchscreen after settling time reached to get both sides of buffer filled
	switch(tsstate)
	{
		case 0: //X-position 1st half of buff filled, switch to 1st half of y buff
			tsstate = 1;
			HAL_TIM_Base_Stop_IT(htimdel);
			HAL_ADC_Start_DMA(hadc, (uint32_t*)yposADC, ADC_BUF_LEN);
			break;
		case 1: //Y-position 1st half of x buff filled, set flag for 1st half update, switch to handling when X is re-found, trigger conversions
			tsstate = 0;
			tsflg = 1;
			HAL_TIM_Base_Stop_IT(htimdel);
			break;
	}
}














//ADC CODE

//when the ADC buffer has been filled, this interrupt runs? Why the if statement, what is hadc1??
//The ADC_Callback function that gets run just changes things from reading the x position to reading 
//the y position (I believe). 

// Called when ADC buffer is completely filled
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) {

	if(hadc == &hadc1)
	{
		//Toggle the touchscreen to read the opposite direction (x->y or y->x)
		TS.ADC_Callback();
	}

}

//Above calls this function - the function just toggles some pins to change which axis reading is occuring?

// DOXYGEN COMMENTING
void TouchscreenDriver::ADC_Callback(void)
{
	//Toggle the touchscreen to read the opposite direction (x->y or y->x)
	HAL_GPIO_TogglePin(PinPort[1], PinArray[1]); // Pin B1 corresponds to UL
	HAL_GPIO_TogglePin(PinPort[2], PinArray[2]); // Pin B2 corresponds to LR

	HAL_TIM_Base_Start_IT(htimdel); //Allow touchscreen settling time to transition before starting DMA again

}




//IMU DMA CODE


//This code runs whenever a certain amount of time has ellapsed for the IMU, just like it did for the touchscreen

//Timer channel callbacks for Touchscreen Settling Time Delay (100-150 us) and IMU Refresh Rate Delay (10 ms)
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	//Touchscreen Switching Interrupt
	if(htim == &htim10)
	{
		TS.TIM_Callback();
	}
	else if(htim == &htim11) //IMU Timing Interrupt
	{
		imu.PollOrientation();
	}

}

//When the period elapsed ISR runs, in response to the IMU, it calls this function and reads the DMA buffer for the IMU??

// From the function description:
//@brief  Reads an amount of data in non-blocking mode with DMA from a specific memory address.

//I think this means it reads the DMA buffer for the IMU without turning off DMA - makes me think this buffer could be written 
//to while it's being read

//Gets Orientation from IMU, stores raw binary into buf.
void IMUDriver::PollOrientation()
{

	HAL_I2C_Mem_Read_DMA(hi2c, BNO055_ADDR, GYR_ADDR, I2C_MEMADD_SIZE_8BIT, buf, 12); //Runs DMA-based mem read of IMU buffer, non-blocking

}

//GYR_ADDR is the address ON THE IMU associated with the gyro data - the HAL_I2C_Mem_Read_DMA 
// function then sends out the read request, and uses DMA to fill "buf" with the 12 byte read
//data that the IMU returns - so this just bypasses some I2C interrupt service routine where the
//user has to write code to handle the received data. 

//THIS CREATES THE FLOATS THAT WILL BE TRANSMITTED OVER USB TO SIMULINK

//Called when I2C completed.
void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
{

	imu.ConvertOrientation(); //Attempt this

}

